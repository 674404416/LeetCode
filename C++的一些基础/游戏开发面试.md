# 游戏开发面试知识

## 1.c++基础知识

### 1.c++引用和指针区别

- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。（引用不能改变地址）
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。



#### 2.c++面向对象的特性

- **多态** ： 一个东西对于不同情况下体现出的不同状态

  - 重载和重写： 重载是有参数不同，重写必须相同
  - 虚函数 ： 要用virtual声明
    - **虚函数** ：是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。
    - 纯虚函数：**需要在基类中定义，但是又不在基类中实现。**virtual int area() = 0;
  - 静态链接和动态链接
    - 静态链接：在编译器编译的时候就连接好的事情
    - 动态链接：在调用的时候连接的事情

- **继承** ：一个类可以继承自多个类，也可以派生多个类

  - 访问修饰符： **public、protected** 或 **private** 。如果未设置就是private。

  - public什么类都可以访问，protected必须是子类或者同一类，private只能自己访问。

  - | 访问     | public | protected | private |
    | :------- | :----- | :-------- | :------ |
    | 同一个类 | yes    | yes       | yes     |
    | 派生类   | yes    | yes       | no      |
    | 外部的类 | yes    | no        | no      |

  

- **封装**：将数据设置成私有的，通过公有的函数来进行对类成员的修改。用户不需要了解它，但它又是类能正常工作所必需的。

  - C++中**, 虚函数**可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。

    

- **抽象**：数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。

  - 优点
    - 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。
    - 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。



#### 3.虚函数表

虚函数的地址存放在虚函数表中，多态是通过虚函数和虚函数表实现的。

详解：https://blog.csdn.net/u012630961/article/details/81226351



#### 4.虚函数和纯虚函数的区别

1. 虚函数是有实现的，纯虚函数没有实现（virtual int area() = 0;）。
2. 虚函数在子类里可以不重载，但是纯虚函数必须重载。
3. 带纯虚函数的类叫抽象类，抽象类不能生成对象。必须纯虚函数重载之后才可以生成对象。



#### 5.虚析构函数的作用

防止内存泄露

具体：https://blog.csdn.net/derkampf/article/details/62093252



#### 6.static和const的区别

static表示是静态的，在函数执行完之后不会释放空间，下次调用还是上次的值。

- static不能在类中初始化，类中只是声明，需要在类的外部初始化。

const在函数执行完之后会释放空间。是一个恒定的**常量。**不能修改。

```c++
class Test
{
public:
	Test() {};
	const int a=1;
	static int b;
	int c = 3;
};
int Test::b = 1;//static初始化
```



#### 7.STL中的Vector、Map、Set底层原理

> 内容来自https://blog.csdn.net/tommyzht/article/details/47312591

1、Vector是顺序容器，是一个动态数组，支持随机存取、插入、删除、查找等操作，在内存中是一块连续的空间。在原有空间不够情况下自动分配空间，增加为原来的两倍。vector随机存取效率高，但是在vector插入元素，需要移动的数目多，效率低下。

注意：**vector动态增加大小时，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，**然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。



2、Map是关联容器，以键值对的形式进行存储，方便进行查找。关键词起到索引的作用，值则表示与索引相关联的数据。以**红黑树**的结构实现，插入删除等操作都在O(logn)时间内完成。

注意：map的下标操作，其行为与vector很不相同：使用一个不在容器中关键字作为下标，会添加一个具有此关键字的元素到map中。一般使用find函数代替下标操作。

3、Set是关联容器，set中每个元素只包含一个关键字。set支持高效的关键字查询操作——检查一个给定的关键字是否在set中。set也是以**红黑树**的结构实现，支持高效插入、删除等操作。



#### 8.map中为何使用红黑树而不是二叉平衡树？

- 红黑树在重新平衡上效率比二叉平衡树高



#### 9.B树和B+树的区别



#### 10.**new/delete与malloc/free的区别**

- new是运算符，malloc是C语言库函数
- new可以重载，malloc不能重载
- new的变量是数据类型，malloc的是字节大小
- new可以调用构造函数，delete可以调用析构函数，malloc/free不能
- new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化
- malloc分配的内存不够的时候可以使用realloc扩容，new没有这样的操作
- new内存分配失败抛出bad_malloc，malloc内存分配失败返回NULL值



## 2.多线程

#### 1.wait和sleep的区别









## 3.网络编程

> 1、TCP的四次挥手
> 2、四次挥手中，TIME-WAIT状态是在哪一步？
> 3、TIME-WAIT()状态下的等待时间是多少？（2*MSL）为何是2*MSL?
> 4、TCP中的流量控制原理
> 5、TCP的拥塞控制原理及实现拥塞控制的主要算法有哪些？（我只说了慢启动，面试官说有四种：①慢启动；②拥塞避免；③快重传；④快恢复）



## 4.数据结构

#### 1.快速排序的思想

#### 2.红黑树的思想



## 5.计算机图形学

#### 1.渲染管线

